#include <rst/lart.h>
#include <sys/task.h>

#include <rst/common.hpp>

#include <string.h>

using namespace __dios::rst::abstract;

/* Abstract versions of arguments and return values are passed in a 'stash', a
 * global (per-thread) location. On 'unstash', we clear the stash for two
 * reasons: 1) it flags up otherwise hard-to-pin bugs where mismatched
 * stash/unstash reads an old value of the stash, and 2) when verification
 * encounters a possible diamond (the explicit content of the state is the
 * same, e.g.  after an if/else) and we leave old stashes around, it might so
 * happen that the stashed values in the candidate states are of different
 * types, leading to a type mismatch in the comparison.
 *
 * TODO The second problem might have to be tackled in the verification
 * algorithm anyway, since there might be other ways to trigger the same
 * problem. */

extern "C"
{
    _LART_INTERFACE void * __lart_unstash()
    {
        auto &stash = __dios_this_task()->__rst_stash;
        auto rv = stash;
        stash = nullptr;
        return rv;
    }

    _LART_INTERFACE void __lart_stash( void *val )
    {
        __dios_this_task()->__rst_stash = val;
    }

    _LART_INTERFACE void __lart_freeze( void *value, void * addr )
    {
        poke_object( value, addr );
    }

    _LART_INTERFACE void * __lart_thaw( void * addr )
    {
        return peek_object< void * >( addr );
    }



    #define operation( name ) \
        _LART_NOINLINE_WEAK \
        uint8_t __lart_abstract_ ## name () { \
            return 0; /* correct index is generated by lart */ \
        }

    operation( op_load )
    operation( op_store )
    operation( op_gep )
    operation( op_alloca )
    operation( op_int_to_fp )
    operation( op_fp_to_int )


    _LART_NOINLINE_WEAK
    void * __lart_get_domain_operation( uint32_t /*domain*/, uint32_t /*op_index*/ ) {
        return nullptr; // implementation is generated by lart
    }
}

/* lifter templates */

using abstract_t = void *;

using alloca_op = abstract_t ( abstract_t size , size_t bitwidth );
using load_op = abstract_t ( abstract_t val, size_t bitwidth );
using store_op = void ( abstract_t val, abstract_t addr, size_t bitwidth );
using gep_op = abstract_t ( size_t base, abstract_t addr, abstract_t off );

using int_to_fp_op = abstract_t ( abstract_t ptr, abstract_t bitwidth );
using fp_to_int_op = abstract_t ( abstract_t ptr, abstract_t bitwidth );

template< typename op_t >
auto get_operation( uint8_t domain, uint8_t op_index ) noexcept
{
    return reinterpret_cast< op_t * >( __lart_get_domain_operation( domain, op_index ) );
}

template< typename concrete_t >
struct argument_t { bool tainted; concrete_t concrete; abstract_t abstract; };

template< typename concrete_t >
argument_t( bool b, concrete_t c, abstract_t a ) -> argument_t< concrete_t >;

#if 0
template< typename value_t >
_LART_INLINE
value_t __lart_load_lifter_impl( abstract_t addr )
{
    auto op = __lart_abstract_op_load();
    auto load = get_operation< load_op >( domain( object( addr ) ), op );
    __lart_stash( load( addr, bitwidth< value_t >() ) );
    return taint< value_t >();
}

#define LART_LOAD_LIFTER( name, value_t ) \
    _LART_INTERFACE \
    value_t __lart_load_lifter_ ##name( abstract_t a_addr ) \
    { \
        return __lart_load_lifter_impl< value_t >( a_addr ); \
    }

template< typename value_t >
_LART_INLINE
void __lart_store_lifter_impl( argument_t< value_t > value
                             , argument_t< void * > addr )
{
    auto bw = bitwidth< value_t >();
    if ( !addr.tainted ) { // therefore value is abstract
        __lart_freeze( value.abstract, addr.concrete );
        return;
    }

    auto op = __lart_abstract_op_store();
    auto store = get_operation< store_op >( domain( addr.abstract ), op );
    abstract_t val = value.tainted ? value.abstract : constant_t::lift( value.concrete );
    store( val, addr.abstract, bw );
}

#define LART_STORE_LIFTER( name, T ) \
    __invisible \
    void __lart_store_lifter_ ##name( bool taint_value, T value, abstract_t a_value \
                                    , bool taint_addr, void * addr, abstract_t a_addr ) \
    { \
        __lart_store_lifter_impl< T >( { taint_value, value, a_value } \
                                     , { taint_addr, addr, a_addr } ); \
    }

template< typename value_t >
_LART_INLINE
abstract_t __lart_gep_lifter_impl( argument_t< void * > ptr
                                 , argument_t< value_t > off
                                 , size_t base )
{
    if ( !ptr.tainted ) { // offset is tainted
        __dios_fault( _VM_Fault::_VM_F_Control, "unsupported abstract offset of concrete pointer" );
        return nullptr;
    }

    auto op = __lart_abstract_op_gep();
    auto gep = get_operation< gep_op >( domain( ptr.abstract ), op );
    auto offset = off.tainted ? off.abstract : constant_t::lift( off.concrete );

    // TODO: correct bytewise index
    __lart_stash( gep( base, ptr.abstract, offset ) );
    return taint< abstract_t >();
}

#define LART_GEP_LIFTER( off_t ) \
    __invisible \
    abstract_t __lart_gep_lifter( bool taint_ptr, void * ptr, abstract_t a_ptr \
                                , bool taint_off, off_t off, abstract_t a_off \
                                , size_t base ) \
    { \
        return __lart_gep_lifter_impl< uint64_t >( { taint_ptr, ptr, a_ptr } \
                                                 , { taint_off, off, a_off } \
                                                 , base ); \
    }

template< typename int_t >
_LART_INLINE
abstract_t __lart_int_to_fp_impl( abstract_t a_int )
{
    auto op = __lart_abstract_op_int_to_fp();
    auto to_fp = get_operation< int_to_fp_op >( domain( a_int ), op );
    auto bw = constant_t::lift( bitwidth< int_t >() );
    return to_fp( a_int, bw );
}

#define LART_INT_TO_FP( name, float_t ) \
    __invisible \
    abstract_t __lart_int_to_ ## name( abstract_t a_int ) \
    { \
        return __lart_int_to_fp_impl< float_t >( a_int ); \
    }

template< typename int_t >
_LART_INLINE
abstract_t __lart_fp_to_int_impl( abstract_t fp)
{
    auto op = __lart_abstract_op_fp_to_int();
    auto to_int = get_operation< fp_to_int_op >( domain( fp ), op );
    auto bw = constant_t::lift( bitwidth< int_t >() );
    return to_int( fp, bw );
}

#define LART_FP_TO_INT( name, int_t ) \
    __invisible \
    abstract_t __lart_fp_to_ ## name( abstract_t fp ) \
    { \
        return __lart_fp_to_int_impl< int_t >( fp ); \
    }

extern "C" {

    _LART_INTERFACE
    void *__lart_alloca_lifter( abstract_t a_size, size_t bw )
    {
        auto op = __lart_abstract_op_alloca();
        auto alloc = get_operation< alloca_op >( domain( object( a_size ) ), op );
        __lart_stash( alloc( a_size, bw ) );
        return taint< void * >( nullptr );
    }

    LART_STORE_LIFTER(  i8, uint8_t )
    LART_STORE_LIFTER( i16, uint16_t )
    LART_STORE_LIFTER( i32, uint32_t )
    LART_STORE_LIFTER( i64, uint64_t )

    LART_LOAD_LIFTER(  i8, uint8_t )
    LART_LOAD_LIFTER( i16, uint16_t )
    LART_LOAD_LIFTER( i32, uint32_t )
    LART_LOAD_LIFTER( i64, uint64_t )

    LART_GEP_LIFTER( uint64_t )

    LART_FP_TO_INT( i8, uint8_t )
    LART_FP_TO_INT( i16, uint16_t )
    LART_FP_TO_INT( i32, uint32_t )
    LART_FP_TO_INT( i64, uint64_t )

    LART_INT_TO_FP( float, float )
    LART_INT_TO_FP( double, double )
}
#endif
