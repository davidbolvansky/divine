// -*- C++ -*- (c) 2013 Vladimír Štill <xstill@fi.muni.cz>

/* ====================== The DIVINE compact file format ======================
 *
 * DIVINE explicit is compact explicit representation of state-space.
 * It can be generated by algorithm gen-explicit, even in distributed way, all
 * parameters that can be passed to divine metrics can be also passed to
 * gen-explicit, for example option to compress state-space when exploring it
 *    $ divine gen-explicit <model> [ --compression=tree ... ]
 * If state space is generated in distributed environment it is
 * expected that output file will be on shared filesystem.
 *
 * Each state in explicit representation is assigned natural number, those
 * numbers are continuous. State with number 0 is virtual state vertex
 * with edges to all initial states of model.
 * This virtual initial vertex is present even in reversed edge encoding,
 * with edges still pointing _toward_ initial states
 *
 * Explicit file format contains
 * - header with meta-information about state-space
 * - encoding of edges in state-space (forward and/or backward)
 * It can also optionally contain
 * - encoding of all reversed edges in state-space
 * - memory of all states
 *
 * Both edges and nodes are encoded in terms of DataBlock object which
 * represents array of variable sized objects. It consists of two arrays
 * (allocated in fact continuously) the first with as many fields of
 * type int64_t as there is nodes in state space. n-th of this fields
 * contains offset of ending of n-th element of array.
 *
 * Edges are encoded by array of destination vertices (index of this
 * array is source vertex), together with label. Their representation is
 * isomorphic to std::tuple< int64_t, Label > where Label can be either
 * uint64_t or empty struct (that is if Label is empty edge encoding is
 * isomorphic to int64_t).
 *
 * Explicit V1 header is 128B long, with fixed format, see struct Header.
 *
 * At runtime, explicit file (with .dess extension -- DiVinE Explicit
 * State Space) is mapped to memory to allow easy access of it.
 * To do this object of type Explicit is used. This object can be copied,
 * but it is shallow copy. File is automatically unmapped when object
 * (all copies) come out of scope. Explicit file is opened either by
 * giving path in constructor or by calling open( string path ) method
 * on object.
 *
 * Writing to Explicit data will result in SIGSEGV or similar if flags
 * for opening are not specified, even then it is thread-unsafe to write here.
 *
 * Because dess files are mapped into memory they are endianity-dependent!
 */

#include <divine/toolkit/probability.h>

#include <cstdint>
#include <cstring>
#include <bitset>
#include <string>
#include <type_traits>
#include <iterator>
#include <algorithm>
#include <memory>
#include <wibble/test.h>
#include <wibble/sfinae.h>
#include <ostream>

#include <unistd.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <fcntl.h>

#ifndef DIVINE_COMPACT_COMPACT_H
#define DIVINE_COMPACT_COMPACT_H

namespace divine {
namespace dess {

enum class Capability : uint64_t {
    ForwardEdges = 0x1,
    BackwardEdges = 0x2,
    Nodes = 0x4,
    UInt64Labels = 0x100,
    Probability = 0x200
};

static inline std::string showCapability( Capability c ) {
#define SHOW_CAPABILITY( C ) if ( c == Capability::C ) return #C;
    SHOW_CAPABILITY( ForwardEdges );
    SHOW_CAPABILITY( BackwardEdges );
    SHOW_CAPABILITY( Nodes );
    SHOW_CAPABILITY( UInt64Labels );
    SHOW_CAPABILITY( Probability );
#undef SHOW_CAPABILITY

    return "<<UNKNOWN=" + std::to_string( uint64_t( c ) ) + ">>";
}


struct Capabilities : std::bitset< 64 > {
    using Base = std::bitset< 64 >;

    Capabilities() = default;
    Capabilities( Capability c ) : Base( uint64_t( c ) ) { }

    Capabilities &operator|=( const Capabilities &o ) {
        Base::operator|=( o );
        return *this;
    }

    friend Capabilities operator|( const Capabilities &a, const Capabilities &b ) {
        return Capabilities( Base( a ) | Base( b ) );
    }

    Capabilities operator&=( const Capabilities &o ) {
        Base::operator&=( o );
        return *this;
    }

    friend Capabilities operator&( const Capabilities &a, const Capabilities &b ) {
        return Capabilities( Base( a ) & Base( b ) );
    }

    bool has( const Capabilities &o ) const {
        return ( (*this) & o ) == o;
    }

    std::string string() const {
        std::stringstream ss;
        for ( uint64_t mask = 1; mask; mask <<= 1 ) {
            if ( ( (*this) & mask ) == mask )
                ss << " | " << showCapability( static_cast< Capability >( mask ) );
        }
        ss << " )";
        auto str = ss.str();
        str[ 1 ] = '(';
        return str.substr( 1 );
    }

  protected:
    Capabilities( const Base &c ) : Base( c ) { }
    Capabilities( uint64_t c ) : Base( c ) { }
};

static const size_t MAGIC_LENGTH = 40UL;
static const char MAGIC[ MAGIC_LENGTH ] = "DIVINE COMPACT EXPLICIT STATE SPACE";
static const int64_t CURRENT_DCESS_VERSION = 1;
static const uint64_t EXPECTED_BYTE_ORDER = 0x0807060504030201ULL;
static const size_t GENERATOR_FIELD_LENGTH = 24UL;

static inline void die( std::string &&msg ) {
    std::cout << msg << std::endl;
    std::abort();
}

struct Header {
    // some meta about divine & compact
    char magic[ MAGIC_LENGTH ];                     //  40B
    uint64_t byteOrder;                             //  48B
    int32_t compactVersion;
    int32_t labelSize;                              //  56B

    static_assert( sizeof( Capabilities ) == 8, "Unexpected size of Capabilities" );
    // informations aubout content of file
    Capabilities capabilities;                      //  64B
    // generator used for nodes (only if nodes are available)
    char generator[ GENERATOR_FIELD_LENGTH ];       //  88B
    int64_t nodeCount;                              //  96B
    // offset to data, from beginning of file
    int64_t dataStartOffset;                        // 104B
    // offset to forward edges, from dataStartOffset
    int64_t forwardOffset;                          // 112B
    int64_t backwardOffset;                         // 120B
    int64_t nodesOffset;                            // 128B

    Header() :
        byteOrder( EXPECTED_BYTE_ORDER ),
        compactVersion( CURRENT_DCESS_VERSION ),
        nodeCount( 0 ),
        dataStartOffset( sizeof( Header ) ),
        forwardOffset( 0 ), backwardOffset( 0 ), nodesOffset( 0 )

    {
        std::copy( MAGIC, MAGIC + MAGIC_LENGTH, magic );
        std::memset( generator, 0, GENERATOR_FIELD_LENGTH );
    }

    static Header *ptr( void *p ) {
        auto ptr = reinterpret_cast< Header * >( p );
        if ( std::memcmp( ptr->magic, MAGIC, MAGIC_LENGTH ) != 0 ) {
            std::cerr << "ERROR: Invalid DiVinE Explicit format" << std::endl;
            std::abort();
        }
        if ( ptr->byteOrder != EXPECTED_BYTE_ORDER ) {
            std::cerr << "ERROR: Invalid byte order (expected 0x" << std::hex
                << EXPECTED_BYTE_ORDER << ", got 0x" << ptr->byteOrder << ")"
                << std::endl;
            std::abort();
        }
        assert_leq( 1, ptr->compactVersion );
        if ( ptr->compactVersion > CURRENT_DCESS_VERSION )
            std::cerr << "WARNING: DCESS file was created by newer version of "
                "DiVinE\n and might not be compatible with this version";
        if ( ptr->capabilities.has( Capability::UInt64Labels ) &&
                ptr->labelSize != sizeof( uint64_t ) )
            die( "ERROR: invalid size of saved labels" );
        if ( ptr->capabilities.has( Capability::Probability ) &&
                ptr->labelSize != sizeof( toolkit::Probability ) )
            die( "Error: invalid size of saved probability labels. ["
                    + std::to_string( ptr->labelSize ) + "] != ["
                    + std::to_string( sizeof( toolkit::Probability ) ) + "]" );
        return ptr;
    }
};

static_assert( sizeof( Header ) == 128, "Wrong size of Header" );

struct DataBlock {
    DataBlock() : _count( 0 ), _indices( nullptr ), _data( nullptr ) { }
    DataBlock( int64_t count, int64_t *indices, char *data ) :
        _count( count ), _indices( indices ), _data( data )
    { }
    template< typename T >
    DataBlock( int64_t count, T *mem ) : _count( count ),
        _indices( reinterpret_cast< int64_t * >( mem ) ),
        _data( reinterpret_cast< char * >( reinterpret_cast< int64_t * >( mem ) + count ) )
    { }

    int64_t count() { return _count; }

    char *operator[]( int64_t ix ) {
        assert_leq( ix, _count );
        return _ix( ix );
    }

    int64_t size( int64_t ix ) {
        int64_t diff = int64_t( _ix( ix + 1 ) ) - int64_t( _ix( ix ) );
        assert_leq( 0, diff );
        return diff;
    }

    template< typename T >
    T &get( int64_t ix ) {
        assert_leq( ix, _count - 1 );
        return *reinterpret_cast< T * >( _ix( ix ) );
    }

    template< typename T >
    struct _MapHelper {
        _MapHelper( char *ptr, int64_t size ) :
            _ptr( reinterpret_cast< T * >( ptr ) ),
            _size( size / sizeof( T ) )
        {
            assert_eq( 0UL, size % sizeof( T ) );
        }

        template< typename Fn >
        auto operator()( Fn fn )
            -> typename std::enable_if< !std::is_void<
                typename std::result_of< Fn( T *, int64_t ) >::type >::value,
                typename std::result_of< Fn( T *, int64_t ) >::type >::type
        {
            return fn( _ptr, _size );
        }

        template< typename Fn >
        auto operator()( Fn fn )
            -> typename std::enable_if< std::is_void<
                typename std::result_of< Fn( T *, int64_t ) >::type >::value,
                void >::type
        {
            fn( _ptr, _size );
        }

      private:
        T* _ptr;
        int64_t _size;
    };


    template< typename T = char >
    _MapHelper< T > map( int64_t ix ) {
        assert_leq( ix, _count - 1 );
        return _MapHelper< T >( _ix( ix ), size( ix ) );
    }
/*
    template< typename T >
    struct Inserter {
        Inserter( DataBlock &db, int64_t from ) :
            _ptr( db._indices + from ),
            _dataNext( reinterpret_cast< T* >( db._data + (from == 0 ? 0 : _ptr[ -1 ]) ) ),
            _dataBlock( &db )
        { }

        template< typename... Args >
        T& emplace( Args &&... args ) {
            new ( _dataNext ) T( std::forward< Args >( args )... );
            T &r = *_dataNext;
            ++_dataNext;
            *_ptr = reinterpret_cast< size_t >( _dataNext )
                - reinterpret_cast< size_t >( _dataBlock->_data );
            assert_leq( 0, *_ptr );
            ++_ptr;
            return r;
        }

      protected:
        int64_t *_ptr;
        T *_dataNext;
        DataBlock *_dataBlock;
    };

    template< typename T >
    Inserter< T > inserter( int64_t from = 0 ) {
        return Inserter< T >( *this, from );
    }
*/
    struct FInserter {
        FInserter( DataBlock &db, int64_t from ) :
            _ptr( db._indices + from ),
            _dataNext( db._data + (from == 0 ? 0 : _ptr[ -1 ]) ),
            _dataBlock( &db )
        { }

        FInserter() : _ptr( nullptr ), _dataNext( nullptr ),
            _dataBlock( nullptr )
        { }

        template< typename Fn >
        auto emplace( int64_t size, Fn fn )
            -> typename std::result_of< Fn( char *, int64_t ) >::type
        {
            assert( _ptr ); assert( _dataNext ); assert( _dataBlock );
            char *data = _dataNext;
            _dataNext += size;
            *_ptr = _dataNext - _dataBlock->_data;
            ++_ptr;
            return fn( data, size );
        }

      protected:
        int64_t *_ptr;
        char *_dataNext;
        DataBlock *_dataBlock;
    };

    FInserter inserter( int64_t from = 0 ) {
        return _count ? FInserter( *this, from ) : FInserter();
    }

    int64_t *lowLevelIndices() { return _indices; }

  private:
    int64_t _count;
    int64_t *_indices;
    char *_data;

    char *_ix( int64_t ix ) {
        assert_leq( 0, ix );
        int64_t i = ix == 0 ? 0 :_indices[ ix - 1 ];
        assert_leq( 0, i );
        return _data + i;
    }
};

// Explicit V1 runtime representation
struct Explicit {

    std::shared_ptr< Header > header;
    DataBlock forward;
    DataBlock backward;
    DataBlock nodes;

    Explicit() : header(),
        forward(), backward(), nodes()
    { }

    Explicit( std::string path, int openmode = O_RDONLY, int mmapProt = PROT_READ ) {
        open( path, openmode, mmapProt );
    }

    void open( std::string path, int openmode = O_RDONLY, int mmapProt = PROT_READ ) {
        struct stat st;
        int fd = ::open( path.c_str(), openmode );
        assert_leq( 0, fd );
        auto r = ::fstat( fd, &st );
        assert_eq( r, 0 );
        static_cast< void >( r );
        size_t size = st.st_size;

        void *ptr = ::mmap( nullptr, size, mmapProt, MAP_SHARED, fd, 0 );
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wold-style-cast"
        assert_neq( ptr, MAP_FAILED );
#pragma GCC diagnostic pop

        finishOpen( fd, ptr, size );
    }

    void finishOpen( int fd, void *ptr, int size ) {
        header = std::shared_ptr< Header >( Header::ptr( ptr ),
                [ fd, size ]( Header *h ) {
                    ::munmap( h, size );
                    ::close( fd );
                } );

        char *cptr = reinterpret_cast< char* >( ptr );

        assert_leq( header->compactVersion, 1 );
        assert_leq( header->dataStartOffset, int64_t( sizeof( Header ) ) );

        if ( header->capabilities.has( Capability::ForwardEdges ) )
            forward = DataBlock( header->nodeCount,
                    cptr + header->dataStartOffset + header->forwardOffset );
        if ( header->capabilities.has( Capability::BackwardEdges ) )
            backward = DataBlock( header->nodeCount,
                    cptr + header->dataStartOffset + header->backwardOffset );
        if ( header->capabilities.has( Capability::Nodes ) )
            nodes = DataBlock( header->nodeCount,
                    cptr + header->dataStartOffset + header->nodesOffset );
    }

    bool valid() { return static_cast< bool >( header ); }
};

namespace {
    struct PrealocateHelper {
        int fd;
        int64_t _edges;
        int64_t _nodes;
        int64_t _nodeDataSize;
        int32_t _labelSize;
        Capabilities _capabilities;
        std::string _generator;

        PrealocateHelper( const std::string &path ) : _edges( 0 ), _nodes( 0 ),
            _nodeDataSize( 0 ), _labelSize( 0 ), _capabilities()
        {
            fd = ::open( path.c_str(), O_RDWR | O_CREAT,
                S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH );
            assert_leq( 0, fd );
        }

        Explicit operator()() {
            assert_leq( 0, fd );
            assert( ( !_capabilities.has( Capability::Probability )
                        && !_capabilities.has( Capability::UInt64Labels ) )
                    || ( _capabilities.has( Capability::Probability )
                        ^ _capabilities.has( Capability::UInt64Labels ) ) );

            int64_t edgeData = sizeof( int64_t ) * _nodes
                + _edges * (sizeof( int64_t ) + _labelSize);
            assert( !_capabilities.has( Capability::UInt64Labels )
                    || _labelSize == sizeof( uint64_t ) );
            assert( !_capabilities.has( Capability::Probability )
                    || _labelSize == sizeof( toolkit::Probability ) );

            int64_t nodeData = sizeof( int64_t ) * _nodes + _nodeDataSize;

            int64_t fileSize = sizeof( Header );
            if ( _capabilities.has( Capability::ForwardEdges ) )
                fileSize += edgeData;
            if ( _capabilities.has( Capability::BackwardEdges ) )
                fileSize += edgeData;
            if ( _capabilities.has( Capability::Nodes ) )
                fileSize += nodeData;


            auto r = ::posix_fallocate( fd, 0, fileSize );
            assert_eq( r , 0 );
            static_cast< void >( r );

            void *ptr = ::mmap( nullptr, fileSize, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0 );
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wold-style-cast"
            assert_neq( ptr, MAP_FAILED );
#pragma GCC diagnostic pop

            Header *h = new ( ptr ) Header();
            h->capabilities = _capabilities;
            h->nodeCount = _nodes;

            h->forwardOffset = 0;
            h->backwardOffset = _capabilities.has( Capability::ForwardEdges )
                ? edgeData : 0;
            h->nodesOffset = h->backwardOffset
                + (_capabilities.has( Capability::BackwardEdges ) ? edgeData : 0);
            h->labelSize = _labelSize;

            Explicit compact;
            compact.finishOpen( fd, ptr, fileSize );

            auto end = _generator.end() - _generator.begin() > int( GENERATOR_FIELD_LENGTH )
                        ? _generator.begin() + GENERATOR_FIELD_LENGTH
                        : _generator.end();
            std::copy( _generator.begin(), end, compact.header->generator );

            fd = -1;
            return compact;
        }

        PrealocateHelper &forward() {
            _capabilities |= Capability::ForwardEdges;
            return *this;
        }

        PrealocateHelper &backward() {
            _capabilities |= Capability::BackwardEdges;
            return *this;
        }

        PrealocateHelper &generator( std::string generator ) {
            _generator = std::move( generator );
            return *this;
        }

        PrealocateHelper &labelSize( size_t size ) {
            assert_eq( _labelSize, 0 );
            _labelSize = size;
            return *this;
        }

        PrealocateHelper &uint64Labels() {
            _capabilities |= Capability::UInt64Labels;
            return *this;
        }

        PrealocateHelper &probability() {
            _capabilities |= Capability::Probability;
            return *this;
        }

        PrealocateHelper &edges( int64_t edges ) {
            assert_eq( _edges, 0 );
            _edges = edges;
            return *this;
        }

        PrealocateHelper &nodes( int64_t nodes ) {
            assert_eq( _nodes, 0 );
            _nodes = nodes;
            return *this;
        }

        PrealocateHelper &saveNodes( int64_t nodesSize ) {
            assert_eq( _nodeDataSize, 0 );
            _nodeDataSize = nodesSize;
            _capabilities |= Capability::Nodes;
            return *this;
        }
    };
}

static inline PrealocateHelper preallocate( const std::string &path ) {
    return PrealocateHelper( path );
}


}
}

#endif // DIVINE_COMPACT_COMPACT_H
