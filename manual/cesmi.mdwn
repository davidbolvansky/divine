Common Explicit-State Model Interface
=====================================

DiVinE provides an implementation for CESMI, which defines a simple common
interface between a model-checking core and a module that generates the state
space of the model in a demand-driven fashion.

CESMI does not specifically demand any concrete implementation of the
interface. DiVinE provides a C-runtime-compatible ABI conforming to the CESMI
specification, as well as C (and C++) and Haskell APIs, which can then be
translated to conform to the provided ABI using standard tools. Loading a
compiled CESMI module is facilitated by using dynamic (shared) libraries on the
target platform: ELF Shared Object files are supported on POSIX platforms, and
Dynamically Linked Libraries (DLLs) on Win32 (Win64) platforms.

DiVinE currently provides two compilers to translate models in specific
modelling formalisms to CESMI modules: a compiler for the DVE language (which
is also supported directly through an interpreter) and a compiler for the
MurPHI language, adapted from the original MurPHI model compiler.

The Specification
-----------------

CESMI is a set of APIs (Application Programming Interface) to represent model
checking problems in a form independent of a specific model-checker. The API is
explicit-state (states of the model are represented discretely) and allows for
implicit (on the fly) representation of models -- local neighborhood of a given
vertex needs to be provided. The exact semantics of vertices and edges
represented by a CESMI model depend on the model checking algorithm in
question. Multiple interpretations of a given graph are possible, and will be
discussed in detail in the section on semantics.

CESMI defines a notion of a "module" and a "loader", the role of the module
corresponding to the model, or a Kripke structure, to be examined. The "loader"
is then a part of a model checking or other model examination tool, which
treats the CESMI module as its input data.

The Module
----------

We will lay out the basic requirements for a CESMI module in this section. The
C prototypes of the individual calls exposed in the API of the module are as
follows:

          void  setup             ( cesmi_setup * );
           int  get_initial       ( cesmi_setup *, int, cesmi_node * );
           int  get_successor     ( cesmi_setup *, int, char *, cesmi_node * );
      uint64_t  get_flags         ( cesmi_setup *, char * );
            int get_property_type ( cesmi_setup *, int );
          char *show_node         ( cesmi_setup *, char * );
          char *show_transition   ( cesmi_setup *, char *, int );
    const char *show_property     ( cesmi_setup *, int );

Only `get_initial` and `get_successor` are mandatory, the rest of the
functionality is optional, and the loader must substitute suitable defaults.

The `setup` call *may* set up any per-instance state, and keep it in the
`instance` pointer of the `cesmi_setup` structure, which has the C definition:

    typedef struct {
        void *allocation_handle;
        cesmi_node (*make_node)( void *handle, int size );
        void *instance; // per-instance data; never touched by DiVinE
        int property_count;
        int instance_initialised;
        /* extensions at the end are ABI-compatible */
    } cesmi_setup;

For each instance of the CESMI module created by the loader, there is a unique
`cesmi_setup` value which is passed to all calls into the module. At the time of
the `setup` call, the `cesmi_setup` structure must be initialised by the loader
to its default state. The `setup` implementation of the module may change the
fields `property_count` and `instance`, the remainder is for *reading only*.

Since the model checker might use the CESMI module in multiple threads, the
CESMI module *must not* retain any global state. All instance-specific state
*must* be managed through the `instance` pointer provided in the `cesmi_setup`
structure. The CESMI loader *may* call `setup` multiple times with a different
parameter (in the same address space), and the resulting CESMI module instances
*must* be fully isolated.

Memory Management
-----------------

The module is responsible for allocating memory for new states, and it must use
the `make_node` function provided in the `cesmi_setup` structure it is given,
passing the `allocation_handle` as its first parameter, and size of the bit
vector it requires. The loader might need to store additional data with the
state, hence it returns a structure with two pointers in it.

    typedef struct {
        void *handle;
        char *memory;
    } cesmi_node;

The `memory` field of the returned structure is for use by the CESMI module to
store state information. The module *must not* alter the `handle` -- it must be
retained in the result of the respective `get_initial` or `get_successor` call.
The `memory` pointer *must not* be passed to `free`. The module should only
call `make_node` at a point where it is known that a state will be generated,
along with its size, otherwise, it will cause undesirable memory leaks.

