#!/bin/bash
# -*- sh -*-

# When running manually:
#   export mode (--export): cwd in source root, no variables should be needed
#   test mode (no flag): cwd in {build directory}/test, set the following variables:
#       OBJ, SRCDIR, BINDIR and optionally TEST_FLAVOUR.
set -e

if test "$1" = "--export"; then
    # Only export the divcheck-readable script (this is used by divbench-import)
    EXPORT=1
    shift

    test -n "$OBJ" || export OBJ=$(make show var=OBJ)
    test -n "$SRCDIR" || export SRCDIR="$PWD"
    test -n "$BINDIR" || export BINDIR="${OBJ}debug" #TODO: default flavour

    addcmds()
    {
        cat
    }

    addcmd()
    {
        echo "$@"
    }

else
    EXPORT= # unset
    dcscript=testcase.divcheck
    # some tests call this already inside correct working directory
    test ! -r lib/testcase || SILENT=1 . lib/testcase

    addcmds()
    {
        cat >> $dcscript
    }
    addcmd()
    {
        echo "$@" >> $dcscript
    }

fi

getopt() { perl -ne "print \$1 if (m,/\* $1: (.*?) \*/, or m,// $1: (.*?)\n,)" $2; }

tags=$(eval echo $(getopt TAGS $1))
opts=$(eval echo $(getopt VERIFY_OPTS $1))
args=$(eval echo $(getopt PROGRAM_OPTS $1))
ccopt=$(eval echo $(getopt CC_OPTS $1))
extrasrc=$(eval echo $(getopt EXTRA_SRCS $1))
expect=$(eval echo $(getopt EXPECT $1))
gtest=
skipcc=$(getopt SKIP_CC $1)

std=
echo "$1" | grep -q '.cpp$' && { echo $ccopts | grep -qv -- '-std'; } && std="-std=c++14"

if test -z "$EXPORT"; then
    if echo $tags | grep -q huge; then
        resources="--max-memory 80GiB --threads 2"
    elif echo $tags | grep -q big; then
        resources="--max-memory 16GiB --max-time 1800 --threads 2"
    else
        resources="--max-memory 4GiB --max-time 600 --threads 2"
    fi
    extra="--report-filename verify.out"
fi

if test "$(eval echo $(getopt USE_GTEST $1))" = 1; then
    gtest="$TESTS/lib/gtest/src/gtest-all.cc $TESTS/lib/gtest/src/gtest_main.cc -I$TESTS/lib/gtest -lm"
fi

if test -z "$EXPORT"; then
    if echo "$opts" | grep -q "symbolic"; then
        solver=$TEST_FLAVOUR
        if test "$solver" = z3 && test $OPT_Z3 = OFF; then skip; fi
        if test "$solver" = stp && test $OPT_STP = OFF; then skip; fi
        if test "$solver" = smtlib; then solver=$solver:z3; z3 --version > /dev/null || skip; fi
        if test "$solver" = vanilla; then solver=none; fi
        if test -n "$solver" ; then
            extra="$extra --solver $solver";
        fi
    elif ! echo "$opts" | egrep -q "leakcheck|relaxed"; then
        # --symbolic currently leaks memory
        extra="$extra --leakcheck exit"
    fi
fi

# Generate 'load' commands
dir=$(dirname $1)
name=$(basename $1)
dios=$SRCDIR/dios
incs="-isystem $dios/include -isystem $dios/libcxx/include"
incs="$incs -isystem $BINDIR/dios/include" #generated headers: hostabi.h etc.
incs="$incs -I $SRCDIR/bricks"
for f in $name $extrasrc; do
    deps=$(cd $dir && clang -I. $incs $std -MM -MT "" $f | \
        sed -e 's,^: [^ ]*,,' -e 's,\\$,,') || true
    addcmd load $dir/$f $f
    for dep in $deps; do
        if ! echo $dep | grep -q '^/'; then dep=$dir/$dep; fi
        addcmd load $dep $(echo $dep | sed -re "s,$dir/*,,")
    done
done

# Generate 'expect' commands (see also test/lib/check verify)
if test -z "$expect"; then
    check=$(readlink -f $(dirname $0)/check)
    chmod +x "$check"
    export DIVCHECK_MODE=1
    (cd $dir ; $check verify $name) | addcmds
else
    addcmd "expect" "$expect"
fi

# Generate 'cc' command
if test "$skipcc" = 1; then
    run=$name
    opts="$std $opts"
else
    addcmd cc -o testcase.bc $std $ccopt "$name" $gtest
    run=testcase.bc
fi

# Generate 'verify' command
addcmd verify $resources $extra $opts $run $args

if test -n "$EXPORT"; then exit 0; fi

cat $dcscript | sed -e 's,^,  | ,'

# Run divcheck with the script
divcheck $dcscript

err=$(grep "error found:" verify.out | cut -d' ' -f3- || true)
if [ "$err" = yes ]; then
    echo "+ divine sim --batch --skip-init --load-report verify.out"
    echo "backtrace" | \
        divine sim --batch --skip-init --load-report verify.out 2>&1 | tee sim.out

    getarg() { perl -ne "print \$1 if m/--$1 +(\\S*)/" $2; }
    location=`getarg location $dcscript`
    symbol=`getarg symbol $dcscript`
    if test -n "$location" && ! grep -q "^  [{}a-zA-Z_].* at $location" sim.out; then
            echo "# expected error to be found in divine sim at $location, but it was not"
            exit 1
    elif test -n "$symbol" && ! grep -qP "^  \\S*$symbol.* at .*" sim.out; then
            echo "# expected error to be found in divine sim in $symbol, but it was not"
            exit 1
    fi
fi

exit 0;

# vim: syntax=sh
